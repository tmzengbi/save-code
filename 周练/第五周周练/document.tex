\documentclass[UTF8]{ctexart}
\usepackage{graphicx}
\usepackage{ulem}
\title{第五周周练题解}
\author{ZeNgBi}
\date{}
\begin{document}
	\maketitle
	\subsection*{P1000.0}
	先用并查集把相连的点全部连起来，可以通过看并查集数组中有几个不同的数来判断连通分量个数
	
	连通变量个数和各个连通分量边数和点数都可以在并查集合并的同时维护，令他们分别为ans1,ans2,ans3。
	
	ans1需要初始化为n，ans3需要初始化为1，因为一开始有n个点，每个点可以单独作为一个连通分量。
	
	每次merge(r1,r2)（合并并查集）如果两个点的爹不一样（后面的r1，r2均表示他们的爹）$ans_1--$；$ans_2[r1]+=ans_2[r2]+1$；$ans_3[r1]+=ans_3[r2]$;
	
	如果两个点的爹一样，只需要ans2[r1]+=1；因为加入这条边只使该连通分量里面边的数量+1。最后分别输出维护的最大值
	\subsection*{P1001.1}
	这题用vector存边就是一个水题:-|
	
	vector存边后sort排序然后unique去重
	
	最后对于每个询问直接输出结果即可。
	\subsection*{P1002.2}
	树的直径可以贪心可以dp，这题看上去贪心似乎做不了orz，所以选择dp
	
	实际上是一个树形dp，原理是把每个子树的根节点到其叶节点的最大距离用dp维护
	
	一直这样维护可以得到整颗树的直径
	
	但是题目需要输出每颗子树的直径，那么需要在dp的过程中加一个数组来维护子树根为i时的树的直径
	
	维护方程为$ans[u]=max(ans[v],ans[u],dp[u]+dp[v]+e.d)$；u指子树的根，v指子树根的儿子，e为u->v的边，e.d为该边的长度。
	
	有坑，答案要用long long存
	
	\subsection*{P1003.3}
	删除这个操作是很难实现的，于是考虑倒序加点。
	
	可以用一个数组纪录哪些点加进去了，加进去的点才有资格拥有边。
	
	然后对于每个加进去的点，遍历它的边，并查集维护连通块数量就可以了。
	
	\subsection*{P1004.4}
	看到这个题第一反应拓扑排序，但是要求答案字典序最小，如果用贪心的思路来给点1-n编号，就会目光短浅，得不到字典序最小的结果。
	
	也可以先去找1然后找2然后……一直找到n来完成整个编号，这样会重复遍历很多边，最坏$O(n^2)$会超时
	
	我们可以换一个思路，存反边，用n-1的顺序来给拓扑排序出的点编号，用优先队列来存点，这样能保证每次拿出的编号都是字典序下最佳答案。
	\subsection*{P1005.5}
	先考虑了暴力，对于随机数据，每条边期望长度为$logn$期望复杂度为$mlogn$是可以过的，但是有毒瘤数据，最后只能过5个点。试了所有常数优化还是tle......
	
	可以用RMQ维护lca，之后用dfs序建线段树维护每个点到根节点的点权和，对于每个修改就将该点和其子树线段树上区间修改，询问就用线段树单点询问然后树上差分可以得到结果。
	
	也可以树链剖分维护点权。所以不用线段树不树剖还带修改要怎么做呀喂。
\end{document}