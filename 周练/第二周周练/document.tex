\documentclass[UTF8]{ctexart}
\title{第二周周练题解}
\author{ZeNgBi}
\date{}
\begin{document}
	\maketitle
	\subsection*{P1000 智乃的思念}
	暴力计算每个数字前面有多少个比它大的数字，时间复杂度O($n^2$)
	\subsection*{P1001 智乃的大思念}
	对于这个数据$n^2$的效率已经无法结束，这里有两种做法
	
	1.考虑归并排序，在归并排序的同时计算逆序对
	
	2.树状数组+离散化
	
	下面说说方法1（方法2留着让大佬去讲吧hhhh
	
	归并排序就不讲了，主要是如何在排序过程中求出逆序对
	
	对于已经排好序的两块1 4 10 | 2 3 6 合并的时候我们会把左右两边i，j对应的较小的那一块拿出来，这个时候发现拿出前面块的数的时候不会对逆序数有影响，\textbf{因为相对顺序没有发生变化}。
	
	
	当拿出后面块的数字时2那么就会导致相对顺序的变化，这个时候2会放在第一块的4和10前面于是逆序对数+=2，拿出3的时候同理。之后会从第一块中拿出4，然后从第二块中拿出6时，6会放在10前面，于是逆序对数+=1。一整个排序下来，逆序对数=5。答案很大，需要long long存，时间复杂度O($nlogn$)
	
	\subsection*{P1002 智乃的大大思念}
	考虑贪心，每次交换就把当前位置的数字放在正确的位置上，然后用交换过来的数字继续放在它正确的位置上，如果这个数字已经不用交换，那么循环遍历找到没有交换的数字继续交换，直到所有数字都在正确的位置上，因为每个数字最多被交换一次，时间复杂度O($nlogn$) ，因为需要离散化，所以需要排序，复杂度上界为排序
	
	\subsection*{P1003 智乃的订单}
	考虑贪心，每个客人的平均等待时间为$\frac{S_n}{n}$， $S_n=\sum_{i=1}^{n} T_i$， $T_i$为第i个客人的等待时间，$T_n$递增，要使$S_n$最小，每次$T_n$增加的值需要最小，即每次选择的t最小。
	
	于是进行排序，然后将前缀和相加得到$S_n$，最后$\frac{S_n}{n}$就是结果
	
	$S_n$很大，需要long long保存。时间复杂度O(nlogn)，复杂度上界为排序
	
	\subsection*{P1004 智乃的惩罚}
	考虑Two pointer，排序后令i=1，j=n。每次循环输出a[i]，a[j]的值，然后令i++，j++，当i>j时跳出循环
	
	时间复杂度O(nlogn)，复杂度上界为排序
	
	
\end{document}